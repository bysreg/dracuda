<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>DRacuda</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">DRacuda</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/bysreg/pcap_cmu_a5" class="btn">View on GitHub</a>
      <a href="https://github.com/bysreg/pcap_cmu_a5/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/bysreg/pcap_cmu_a5/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors</h3>

<p>Muhammad Hilman Beyri (mbeyri), Zixu Ding (zixud)</p>

<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary</h3>

<p>We are going to create a cloud-based real-time CUDA ray tracer application framework which helps developing graphics demanding applications.</p>

<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h3>

<p>In computer graphics, ray tracing is a technique for generating an image by tracing the path of light through pixels in an image plane and simulating the effects of its encounters with virtual objects. As such, ray tracing is able to simulate necessary effects to create photorealistic images. However, a high-quality ray tracing can take very long time to render, and is not suitable for real-time applications.
</p>

<p>GPU, as a powerful SIMD processing unit, performs well in data-parallel and math-intensive tasks. Essential operations in ray tracing, such as intersection tests, transformations, vector math and shading are all GPU-friendly. According to several benchmarks provided by developers in universities, GPU ray tracers implementations had 100x - 300x speedup compared to CPU counterparts. It is then proved that GPU is a natural choice for ray tracing and is much more suitable than CPU.</p>

<p>With the advent of cloud computing, it is possible to access massive computing resources without actually purchasing them. Even GPU computing instances have become available in the past few years. Therefore, with enough GPUs, real-time rendering is possible without sacrificing the quality.</p>

<p>Load balancing across heterogeneous nodes can be difficult. That is largely due to the differences of network latency and GPU performance among nodes. In order to balance the overall latency, which we estimate as network latency + work load * rendering time per unit work load, we will gather the rendering time and latency from worker nodes, and use an adaptive linear regression algorithm to predict the network latency and unit rendering time of next frame, and then assign the work load of each node accordingly.</p>

<p>The architecture of this project is simple. Worker nodes are responsible for rendering. They take scene data and the work assignment information (like from Row A - Row B) as input, and send back the rendered portion of the image (compressed). The local client divides the screen into tiles, send the scene data and work allocation to worker nodes, and collects all the image parts from worker nodes and display the frames. It also adjusts the work assignment each frame using the adaptive algorithm we mentioned above.</p>

<p>We might potentially use k-d tree for acceleration structure if the scene is large enough. But for general use cases, we would use plain intersection tests to keep the raytracer SIMD-friendly.</p>

<h3>

<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Challenge</h3>
<p>
Performance
<ul>
<li>Network Latency. The latency from Pittsburgh to Amazon US East server is 23 ms. A round-trip would be 46 ms. For a player to not experience lag, the latency has to be below 100 ms, so that restricts the rendering time under 50 ms. Besides, we are aiming for a frame rate of at least 30 FPS, our goal is to limit the rendering time of each frame to below 33 ms, to ensure the throughput is enough for the 30 FPS experience.</li>
<li>Load Balancing Algorithm. Different compute nodes have different rendering performance and network latency. Therefore it is challenging to balance the overall latency of all nodes. We will continuously gather analytics data from nodes to adaptively balance the latency.</li>
<li>Efficient GPU ray tracing implementation. Even though ray tracing is highly parallelizable, there are branch divergences in intersection tests, refraction / reflections, which can cause huge performance slowdown if not handled properly.</li>
</ul>
Graphics
<ul>
<li>Photorealistic Rendering. To make the rendering as pretty as possible, some effects like caustics, subsurface scattering, diffuse reflection are both difficult to simulate and computationally intensive.</li>

</ul>
</p>

<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><h3>Resources</h3>
<p>
We have taken 15-662 Computer Graphics and developed a ray tracer on CPU. We will rewrite the ray tracer on GPU. During the development, we will use GHC clusters with GPU to test. We will also make sure it works on Amazon EC2, and will run the demo game on it.
</p>

<h3>Goals and Deliverables</h3>
<p>
	We plan to achieve:
	<ul>
	<li>Distributed parallel ray tracing using CUDA</li>
	<li>Load balancer algorithm that adapts to the network latency and worker nodes' computation time</li>
	<li>API to create distributed ray tracing application</li>
	<li>A game as an example of one of the ray tracing application</li>
	<li>Analysis of the performance of the ray tracer. We hope to achieve real time performance with high quality images</li>
	</ul>
	
	We hope to achieve:
	<ul>
	<li>Particle simulation using material point method</li>
	<li>Subsurface scattering</li>
	<li>CPU and GPU Hybrid parallelization</li>
	</ul>
</p>

<h3>Platform Choice</h3>
<p>
	We are using CUDA and C++ as our main programming language. The client will be a thin client application using SDL and OpenGL. The client will communicate with other worker nodes using a network protocol that we are going to design. We chose to assume the worker nodes have GPUs that support CUDA.
</p>

<h3>Schedule</h3>
<p>
	<ul>
		<li>Thursday, April 7: Implement working parallel ray tracer on single GPU</li>
		<li>Thursday, April 14: Implement communication protocol and working distributed parallel ray tracer</li>
		<li>Thursday, April 21: Implement a demo game</li>
		<li>Thursday, April 28: Optimize load balancer algorithm</li>
		<li>Thursday, May 5: Final overall optimization and write analysis and presentation</li>
		<li>Monday, May 9: Presentation</li>
	</ul>
</p>


      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
